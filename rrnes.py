# -*- coding: utf-8 -*-
"""
Created on Sun Jun 21 21:54:32 2020

@author: kangsun
"""
import h5py
import numpy as np
import datetime as dt
from dateutil.relativedelta import relativedelta
import logging
import os

class RRNES(object):
    def __init__(self,whichBasin,whichSatellite,
                 dateArray,dataDir):
        """
        whichBain:
            'po', 'jh', or 'so'
        whichSatellite:
            'TROPOMI' or 'OMI'
        dateArray:
            a numpy array of datetime.date objects, where year/month are used to identify which month(s) to load
        dataDir:
            directory of h5 files generated by S_save_basin_wind_aggregation.m
        """
        self.logger = logging.getLogger(__name__)
        self.logger.info('creating an instance of MonthlyIME')
        self.whichBasin = whichBasin
        self.whichSatellite = whichSatellite
        self.dateArray = dateArray
        self.dataDir = dataDir
        
    def F_load_monthly_h5(self,fileNameArray=[],fileIntegrationMonth=1):
        """
        load monthly data to a numpy array of dictionaries, each dict will be data for a month
        By default, no inputs are needed, as months are defined previously by
        self.dateArray
        fileNameArray:
            if provided, it should be a list of file names, e.g., ['TROPOMI_201805to201805.h5']
        fileIntegrationMonth:
            by default one, i.e., monthly. How many months are integrated in S_save_basin_wind_aggregation.m
        """
        if not fileNameArray:
            fileNameArray = [os.path.join(self.dataDir,self.whichSatellite+'_'+
                                          Date.strftime('%Y%m')+'to'+
                                          (Date+relativedelta(months=fileIntegrationMonth-1)).strftime('%Y%m')+'.h5') \
                            for Date in self.dateArray]
            self.logger.info('no file names are supplied, assuming standard file name format')
        
        self.fileNameArray = fileNameArray
        monthlyDictArray = np.empty((len(fileNameArray)),dtype=object)
        for ifile,fileName in enumerate(fileNameArray):
            m = {}
            if not os.path.exists(fileName):
                self.logger.warning(fileName+' does not exist! returning empty dict')
                monthlyDictArray[ifile] = {}
                continue
            self.logger.info('loading '+fileName)
            with h5py.File(fileName,mode='r') as f:
                for key in list(f['/'+self.whichBasin].keys()):
                    if key not in {'NO2','CO'}:
                        m[key] = f['/'+self.whichBasin+'/'+key][:].squeeze()
                    elif key == 'NO2':
                        m['NO2'] = {}
                        for k in list(f['/'+self.whichBasin+'/NO2'].keys()):
                            m['NO2'][k] = f['/'+self.whichBasin+'/NO2/'+k][:].squeeze()
                    elif key == 'CO':
                        m['CO'] = {}
                        for k in list(f['/'+self.whichBasin+'/CO'].keys()):
                            m['CO'][k] = f['/'+self.whichBasin+'/CO/'+k][:].squeeze()
            monthlyDictArray[ifile] = m
        self.monthlyDictArray = monthlyDictArray
    
    def F_merge_monthly_data(self):
        """
        merge self.monthlyDictArray to a single dict. data fields are weight-
        averaged as needed. The result is self.mergedDict
        """
        from copy import deepcopy
        if len(self.monthlyDictArray) == 1:
            self.logger.info('only one month data, no merging is needed')
            self.mergedDict = self.monthlyDictArray[0]
            return
        mergedDict = {}
        for idict,d in enumerate(self.monthlyDictArray):
            if not d:
                self.logger.warning(self.dateArray[idict].strftime('%Y%m')+' gives empty data!')
                continue
            if not mergedDict:
                self.logger.info('initiate merge with data in '+self.dateArray[idict].strftime('%Y%m'))
                mergedDict = deepcopy(d)
            else:
                self.logger.info('merging with data in '+self.dateArray[idict].strftime('%Y%m'))
                for key in ['NO2','CO']:
                    if key not in mergedDict.keys():
                        self.logger.info(key+' is not a key in the dict')
                        continue
                    ime_B1 = mergedDict[key]['ime_B'].copy()
                    ime_B2 = d[key]['ime_B'].copy()
                    ime_B3 = ime_B1+ime_B2
                    for k in d[key].keys():
                        if k in ['ime_D','ime_B']:
                            # layers of pixels and weights are simply additive
                            mergedDict[key][k] = mergedDict[key][k]+\
                            d[key][k]
                        elif 'ime' in k:
                            # ime fields (ime_ws, ime_C, etc.) should be weight-averaged
                            mergedDict[key][k] = (mergedDict[key][k]*ime_B1+\
                            d[key][k]*ime_B2)/ime_B3
                        elif k == 'A_vec':
                            mergedDict[key][k] = np.column_stack((mergedDict[key][k],d[key][k]))
                        else:
                            # non-ime fields should be concatenated together
                            array1 = mergedDict[key][k].copy()
                            array2 = d[key][k].copy()
                            if array1.ndim == 0:
                                array1 = np.array([array1])
                            if array2.ndim == 0:
                                array2 = np.array([array2])
                            mergedDict[key][k] = np.concatenate((array1,array2))
        self.mergedDict = mergedDict    
