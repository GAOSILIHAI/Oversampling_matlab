# -*- coding: utf-8 -*-
"""
Created on Sun Jun 21 21:54:32 2020

@author: kangsun
"""
import h5py
import numpy as np
import datetime as dt
from dateutil.relativedelta import relativedelta
import logging
import os
import pandas as pd

def F_delta_omega(inp,Q,tau):
    """
    forward model for F_fit_ime_C
    """
    A = inp['A']
    L = inp['L']
    ws = inp['ws']
    f = inp['f']
    if 'Omega_bg' not in inp.keys():
        return Q/(A*(ws/L/f+1/tau))
    else:
        return (Q+inp['Omega_bg']*ws*A/f/L)/(A*(ws/L/f+1/tau))

def F_forward(inp,Q,tau):
    """
    forward model for F_GaussNewton_OE
    """
    A = inp['A']
    L = inp['L']
    ws = inp['ws']
    f = inp['f']
    if 'Omega_bg' not in inp.keys():
        y = Q/(A*(ws/L/f+1/tau))
        dydQ = 1/(A*(ws/L/f+1/tau))
        dydtau = Q/A*1/(ws/L/f+1/tau)**2*1/tau**2
        return y, dydQ, dydtau
    else:
        y = (Q+inp['Omega_bg']*ws*A/f/L)/(A*(ws/L/f+1/tau))
        dydQ = 1/(A*(ws/L/f+1/tau))
        dydtau = (Q+inp['Omega_bg']*ws*A/f/L)/A*1/(ws/L/f+1/tau)**2*1/tau**2
        return y, dydQ, dydtau
        

class IME():
    """
    place holder for output object of F_fit_ime_C
    """
    pass

class IMEOE():
    """
    place holder for output object of F_GaussNewton_OE
    """
    pass

class RRNES(object):
    def __init__(self,whichBasin,whichSatellite,
                 dateArray,dataDir,
                 moleculeList=['NO2'],
                 inventoryPathList=[]):
        """
        whichBain:
            'po', 'jh', or 'so'
        whichSatellite:
            'TROPOMI' or 'OMI'
        dateArray:
            a numpy array of datetime.date objects, where year/month are used to identify which month(s) to load
        dataDir:
            directory of h5 files generated by S_save_basin_wind_aggregation.m
        coInventoryPath:
            path to the monthly CO emission inventory
        no2InventoryPath:
            path to the monthly NO2 emission inventory
        """
        self.logger = logging.getLogger(__name__)
        self.logger.info('creating an instance of MonthlyIME')
        self.whichBasin = whichBasin
        self.whichSatellite = whichSatellite
        self.dateArray = dateArray
        self.dataDir = dataDir
        self.moleculeList = moleculeList
        if len(inventoryPathList) > 0:
            if len(inventoryPathList) != len(moleculeList):
                self.logger.error('length of molecules have to be the same as length of inventory')
            self.logger.info('loading monthly emission estimates')
            self.inventories = {}
            for (i,molecule) in enumerate(moleculeList):
                T = pd.read_csv(inventoryPathList[i],index_col=0) # mol/s
                self.inventories[molecule] = np.array([T.loc[d.year].iloc[d.month-1] for d in dateArray])
        
    def F_load_monthly_h5(self,fileNameArray=[],fileIntegrationMonth=None):
        """
        load monthly data to a numpy array of dictionaries, each dict will be data for a month
        By default, no inputs are needed, as months are defined previously by
        self.dateArray
        fileNameArray:
            if provided, it should be a list of file names, e.g., ['TROPOMI_201805to201805.h5']
        fileIntegrationMonth:
            by default one, i.e., monthly. How many months are integrated in S_save_basin_wind_aggregation.m
        output:
            monthlyDictArray is an numpy array of dictionaries. each dictionary corresponds to one month by default
        """
        if not fileNameArray:
            self.logger.info('no file names are supplied, assuming standard file name format')
            if fileIntegrationMonth == None:
                fileNameArray = [os.path.join(self.dataDir,self.whichSatellite+'_'+
                                              Date.strftime('%Y%m')+'.h5') \
                                for Date in self.dateArray]
            else:    
                fileNameArray = [os.path.join(self.dataDir,self.whichSatellite+'_'+
                                              Date.strftime('%Y%m')+'to'+
                                              (Date+relativedelta(months=fileIntegrationMonth-1)).strftime('%Y%m')+'.h5') \
                                for Date in self.dateArray]
        self.fileNameArray = fileNameArray
        monthlyDictArray = np.empty((len(fileNameArray)),dtype=object)
        for ifile,fileName in enumerate(fileNameArray):
            m = {}
            if not os.path.exists(fileName):
                self.logger.warning(fileName+' does not exist! returning empty dict')
                monthlyDictArray[ifile] = {}
                continue
            self.logger.info('loading '+fileName)
            with h5py.File(fileName,mode='r') as f:
                for key in list(f['/'+self.whichBasin].keys()):
                    if key not in {'NO2','CO'}:
                        m[key] = f['/'+self.whichBasin+'/'+key][...].squeeze()
                    elif key == 'NO2':
                        m['NO2'] = {}
                        for k in list(f['/'+self.whichBasin+'/NO2'].keys()):
                            m['NO2'][k] = f['/'+self.whichBasin+'/NO2/'+k][...].squeeze()
                    elif key == 'CO':
                        m['CO'] = {}
                        for k in list(f['/'+self.whichBasin+'/CO'].keys()):
                            m['CO'][k] = f['/'+self.whichBasin+'/CO/'+k][...].squeeze()
            monthlyDictArray[ifile] = m
        return monthlyDictArray
    
    def F_sum_IME_to_emission(self,monthlyDict,tau,ime_f=[],if_use_ws=True,wsRange=(0.,21.)):
        '''
        weight-sum the arrays in ime to emission
        tau:
            chemical lifetime in s
        '''
        U = monthlyDict['NO2']['ime_ws']
        if len(ime_f)==0:
            ime_f = 2*np.ones(U.shape)
        elif len(ime_f)==1:
            ime_f = ime_f*np.ones(U.shape)
        mask = (U >= wsRange[0]) & (U <= wsRange[1])
        U = U[mask]
        ime_f = ime_f[mask]
        yData = monthlyDict['NO2']['ime_C'][mask]
#        if self.whichSatellite == 'OMI':
#            yData = monthlyDict['NO2']['ime_C'][mask]/6.02214e19
#        elif self.whichSatellite == 'TROPOMI':
#            yData = monthlyDict['NO2']['ime_C'][mask]        
        weight = monthlyDict['NO2']['ime_B'][mask]
        A = monthlyDict['L']**2
        L = monthlyDict['L']
        if if_use_ws:
            ime_Q = yData*A*(U/L/ime_f+1/tau)
        else:
            ime_Q = yData*A/tau
        
        Q = np.nansum(ime_Q*weight)/np.nansum(weight)
        return Q
    def F_GaussNewton_OE(self,monthlyDict,ime_f=[],initialGuess=(500.,10800.),
                    ridgeLambda = 1e-10,priorSD=(300,7200),priorRho=0.2,
                    wsRange=(2.,8.),tol=1e-10,maxIteration=100):
        """
        fit emission Q and chemical lifetime tau from ime_C vs. ime_ws using optimal estimation
        monthlyDict:
            one element in monthlyDictArray that output from F_load_monthly_h5, 
            or the mergedDict from F_merge_monthly_data
        ime_f:
            an array of same size as monthlyDict['NO2']['ime_C']
        intitialGuess:
            prior of (Q,tau)
        ridgeLambda:
            scaling factor of prior error, 0 reduces to no prior. 
            effectively observation error variance. 3 month running climatology gives median rms of 1.05e-5, so 1e-10 is default
        priorSD:
            prior error standard deviation of Q and tau
        priorRho:
            prior error correlation coefficient of Q and tau
        wsRange:
            in m/s, range where ime_C are fitted
        tol:
            tolerance of relative state vector length change
        maxIteration:
            as indicated
        """
        xData = monthlyDict['NO2']['ime_ws']
        yData = monthlyDict['NO2']['ime_C']
#        if self.whichSatellite == 'OMI':
#            yData = monthlyDict['NO2']['ime_C']/6.02214e19
#        elif self.whichSatellite == 'TROPOMI':
#            yData = monthlyDict['NO2']['ime_C']
        sData = monthlyDict['NO2']['ime_D']
        if len(ime_f) == 0:
            ime_f = 2*np.ones(xData.shape)
        elif len(ime_f) == 1:
            ime_f = ime_f*np.ones(xData.shape)
        mask = (~np.isnan(xData)) & (~np.isnan(yData)) & (xData >= wsRange[0]) & (xData <= wsRange[1])
        xData0 = xData[mask]
        yData0 = yData[mask]
        sData0 = sData[mask]
        ime_f = ime_f[mask]
        
        inp = {}
        inp['A'] = monthlyDict['L']**2
        inp['L'] = monthlyDict['L']
        inp['ws'] = xData0
        inp['f'] = ime_f
        
        y0,dy0dQ,dy0dtau = F_forward(inp,*initialGuess)
        K = np.column_stack((dy0dQ,dy0dtau))
        beta0 = np.array(initialGuess,dtype=np.float)
        y0 = F_forward(inp,*beta0)[0]
        beta = beta0
        Sa = np.eye(2)
        Sa[0,0] = (priorSD[0]**2)
        Sa[1,1] = (priorSD[1]**2)
        Sa[1,0] = priorRho*priorSD[0]*priorSD[1]
        Sa[0,1] = Sa[1,0]
#        Sa[1,1] = (1/beta0[0]*beta0[1])**2
        Sa_inv = np.linalg.inv(Sa)*ridgeLambda
        count = 0
        diffNorm = tol+1
        self.logger.info('Q = %.1f'%beta[0]+', tau = %.1f'%(beta[1]/3600))
        while (diffNorm > tol and count < maxIteration):
            try:
                y,dydQ,dydtau = F_forward(inp,*beta)
                K = np.column_stack((dydQ,dydtau))
                dbeta = np.linalg.inv(Sa_inv+K.T@K)@(K.T@(yData0-y)-Sa_inv@(beta-beta0))
                norm_dbeta = dbeta/beta0
                diffNorm = np.linalg.norm(norm_dbeta)
                beta = beta+dbeta
                count = count+1
            except Exception as e:
                self.logger.warning('Fitting error occurred at iteration%d'%count)
                self.logger.warning(e)
                break
            self.logger.info('step %d'%count)
            self.logger.info('relative increment: %.3e'%diffNorm)
            self.logger.info('Q = %.1f'%beta[0]+', tau = %.1f'%(beta[1]/3600))
            if count == maxIteration:
                self.logger.warning('max iteration number reached!')
        
        imeFit = IMEOE()
        imeFit.popt = beta
        imeFit.xData0 = xData0
        imeFit.yData0 = yData0
        imeFit.sData0 = sData0
        imeFit.yHat0 = y0
        imeFit.yHat = y
        imeFit.jacobian = K
        imeFit.residual0 = yData0-y
        imeFit.residualRMS = np.sqrt(np.sum(np.power(yData0-y,2)))
        imeFit.nIter = count
        return imeFit
        
    def F_fit_ime_C(self,monthlyDict,ime_f=[],initialGuess=(500.,10800.),
                    wsRange=(2.,8.),softResidualThreshold=0.2):
        """
        fit emission Q and chemical lifetime tau from ime_C vs. ime_ws
        monthlyDict:
            one element in monthlyDictArray that output from F_load_monthly_h5, 
            or the mergedDict from F_merge_monthly_data
        ime_f:
            an array of same size as monthlyDict['NO2']['ime_C']
        intitialGuess:
            prior of (Q,tau)
        wsRange:
            in m/s, range where ime_C are fitted
        softResidualThreshold:
            points with relative (to yHat) residual larger than that will be
            removed, and fit another time
        """
        from scipy.optimize import curve_fit
#        self.logger.info('fitting year %d'%monthlyDict['NO2']['year_vec']+', month %d'%monthlyDict['NO2']['month_vec'])
        xData = monthlyDict['NO2']['ime_ws']
        if 'ime_C_bg' not in monthlyDict['NO2'].keys():
            self.logger.warning('background column does not exist! use zeros')
            yBG = xData*0.
        else:
            yBG = monthlyDict['NO2']['ime_C_bg']
        yBG = xData*0.
        yData = monthlyDict['NO2']['ime_C']
#        if self.whichSatellite == 'OMI':
#            yData = monthlyDict['NO2']['ime_C']/6.02214e19
#            yBG = yBG/6.02214e19
#        elif self.whichSatellite == 'TROPOMI':
#            yData = monthlyDict['NO2']['ime_C']
        sData = monthlyDict['NO2']['ime_D']
        if len(ime_f) == 0:
            ime_f = 2*np.ones(xData.shape)
        elif len(ime_f) == 1:
            ime_f = ime_f*np.ones(xData.shape)
        mask = (~np.isnan(xData)) & (~np.isnan(yData)) & (xData >= wsRange[0]) & (xData <= wsRange[1])
        xData0 = xData[mask]
        yData0 = yData[mask]
        sData0 = sData[mask]
        yBG = yBG[mask]
        ime_f = ime_f[mask]
        # first round
        inp = {}
        inp['A'] = monthlyDict['L']**2
        inp['L'] = monthlyDict['L']
        inp['ws'] = xData0
        inp['f'] = ime_f
        inp['Omega_bg'] = yBG
        try:
            popt0,pcov0 = curve_fit(F_delta_omega,inp,yData0,p0=initialGuess)
            yHat0 = F_delta_omega(inp,*popt0)
            residual0 = yData0-yHat0
        except Exception as e:
            self.logger.warning('fitting error occurred');
            print(e)
            imeFit = IME()
            imeFit.xData0 = xData0
            imeFit.yData0 = yData0
            imeFit.sData0 = sData0
            imeFit.yBG = yBG
            imeFit.yHat0 = xData0*np.nan
            imeFit.residual0 = xData0*np.nan
            imeFit.popt0 = np.full((2),np.nan)
            imeFit.pcov0 = np.full((2,2),np.nan)
            imeFit.xData1 = xData0
            imeFit.yData1 = yData0
            imeFit.sData1 = sData0
            imeFit.yHat1 = xData0*np.nan
            imeFit.residual1 = xData0*np.nan
            imeFit.popt1 = np.full((2),np.nan)
            imeFit.pcov1 = np.full((2,2),np.nan)
            return imeFit
            
        imeFit = IME()
        imeFit.xData0 = xData0
        imeFit.yData0 = yData0
        imeFit.sData0 = sData0
        imeFit.yHat0 = yHat0
        imeFit.residual0 = residual0
        imeFit.popt0 = popt0
        imeFit.pcov0 = pcov0
        
        mask = (np.abs(residual0) <= softResidualThreshold*yHat0)
        if np.sum(~mask) > 0:
            self.logger.warning('%d'%np.sum(~mask)+' residuals larger than %d%%'%(softResidualThreshold*100)+', remove and fit again...')
        else:
            imeFit.xData1 = xData0
            imeFit.yData1 = yData0
            imeFit.sData1 = sData0
            imeFit.yBG = yBG
            imeFit.yHat1 = yHat0
            imeFit.residual1 = residual0
            imeFit.popt1 = popt0
            imeFit.pcov1 = pcov0
            return imeFit
        xData1 = xData0[mask];yData1 = yData0[mask];
        sData1 = sData0[mask];yBG = yBG[mask];ime_f = ime_f[mask]
        
        inp['ws'] = xData1
        inp['f'] = ime_f
        inp['Omega_bg'] = yBG
        try:
            popt1,pcov1 = curve_fit(F_delta_omega,inp,yData1,p0=initialGuess)
            yHat1 = F_delta_omega(inp,*popt1)
            residual1 = yData1-yHat1
        except Exception as e:
            self.logger.warning('fitting error occurred');
            print(e)
            yHat1 = np.nan*yData0
            residual1 = np.nan*yData0
            popt1 = np.full((2),np.nan)
            pcov1 = np.full((2,2),np.nan)
        imeFit.xData1 = xData1
        imeFit.yData1 = yData1
        imeFit.sData1 = sData1
        imeFit.yBG = yBG
        imeFit.yHat1 = yHat1
        imeFit.residual1 = residual1
        imeFit.popt1 = popt1
        imeFit.pcov1 = pcov1
        return imeFit
        
    def F_monthly_f_number(self,monthlyDictArray):
        """
        calculate f number using monthlyDictArray and coQArray from previous steps
        """
        return np.array([d['CO']['ime_x']*d['CO']['ime_sp']*d['CO']['ime_ws']*d['L']\
                  /self.inventories['CO'][ind]/9.8/0.029 for (ind,d) in enumerate(monthlyDictArray)])
    
    def F_merge_monthly_data(self,monthlyDictArray):
        """
        merge monthlyDictArray to a single dict. data fields are weight-
        averaged as needed. The result is mergedDict
        """
        from copy import deepcopy
        if len(monthlyDictArray) == 1:
            self.logger.info('only one month data, no merging is needed')
            mergedDict = monthlyDictArray[0]
            return mergedDict
        mergedDict = {}
        for idict,d in enumerate(monthlyDictArray):
            if not d:
                self.logger.warning('%02d'%d['NO2']['month_vec']+'/%04d'%d['NO2']['year_vec']+' gives empty data!')
                continue
            if not mergedDict:
                self.logger.info('initiate merge with data in '+'%02d'%d['NO2']['month_vec']+'/%04d'%d['NO2']['year_vec'])
                mergedDict = deepcopy(d)
            else:
                self.logger.info('merging with data in '+'%02d'%d['NO2']['month_vec']+'/%04d'%d['NO2']['year_vec'])
                for key in self.moleculeList:
                    if key not in mergedDict.keys():
                        self.logger.info(key+' is not a key in the dict')
                        continue
                    ime_B1 = mergedDict[key]['ime_B'].copy()
                    ime_B2 = d[key]['ime_B'].copy()
                    ime_B3 = ime_B1+ime_B2
                    ime_B1[np.isnan(ime_B1)] = 0.
                    ime_B1[np.isnan(ime_B2)] = 0.
                    ime_B1[np.isnan(ime_B3)] = 0.
                    for k in d[key].keys():
                        if k in ['ime_D','ime_B']:
                            # layers of pixels and weights are simply additive
                            mergedDict[key][k][np.isnan(mergedDict[key][k])] = 0
                            d[key][k][np.isnan(d[key][k])] = 0
                            mergedDict[key][k] = mergedDict[key][k]+\
                            d[key][k]
                        elif 'ime' in k:
                            # ime fields (ime_ws, ime_C, etc.) should be weight-averaged
                            mergedDict[key][k][np.isnan(mergedDict[key][k])] = 0
                            d[key][k][np.isnan(d[key][k])] = 0
                            mergedDict[key][k] = (mergedDict[key][k]*ime_B1+\
                            d[key][k]*ime_B2)/ime_B3
                        elif k == 'A_vec':
                            mergedDict[key][k] = np.column_stack((mergedDict[key][k],d[key][k]))
                        else:
                            # non-ime fields should be concatenated together
                            array1 = mergedDict[key][k].copy()
                            array2 = d[key][k].copy()
                            if array1.ndim == 0:
                                array1 = np.array([array1])
                            if array2.ndim == 0:
                                array2 = np.array([array2])
                            mergedDict[key][k] = np.concatenate((array1,array2))
        return mergedDict    
